# Polymarket PnL Replayer - 第一阶段：RPC数据准备

## 目标合约

| 合约 | 地址 | 起始区块 |
|------|------|----------|
| ConditionalTokens | 0x4D97DCd97eC945f40cF65F87097ACe5EA0476045 | 4023686 |
| CTFExchange | 0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E | 33605403 |
| NegRiskCTFExchange | 0xC5d563A36AE78145C45a50134d48A1215220f80a | 50505492 |
| NegRiskAdapter | 0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296 | 50505403 |

---

## 事件数据结构

### 1. ConditionalTokens

#### TransferSingle (topic0: 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62)
```cpp
struct TransferSingle {
    address operator;      // indexed, 操作者
    address from;          // indexed, 发送方 (0x0=mint)
    address to;            // indexed, 接收方 (0x0=burn)
    uint256 id;            // positionId (ERC1155 tokenId)
    uint256 value;         // 数量
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

#### TransferBatch (topic0: 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb)
```cpp
struct TransferBatch {
    address operator;      // indexed
    address from;          // indexed
    address to;            // indexed
    uint256[] ids;         // positionId数组
    uint256[] values;      // 数量数组
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

#### PositionSplit (topic0: 0x2e6bb91f8cbcda0c93623c54d0403a43514f4b3a3babf4d7a8e50cf2a7b9d435)
```cpp
struct PositionSplit {
    address stakeholder;       // indexed, 操作用户
    address collateralToken;   // USDC地址
    bytes32 parentCollectionId;// indexed, 通常为0x0
    bytes32 conditionId;       // indexed
    uint256[] partition;       // [1,2] = YES+NO
    uint256 amount;            // USDC数量 (6 decimals)
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

#### PositionsMerge (topic0: 0x7a843b0eb41f7a3d57a525b61f6f6584f1d68f403e8917cb9d753ddb6d0e3e2e)
```cpp
struct PositionsMerge {
    address stakeholder;       // indexed
    address collateralToken;
    bytes32 parentCollectionId;// indexed
    bytes32 conditionId;       // indexed
    uint256[] partition;
    uint256 amount;
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

#### PayoutRedemption (topic0: 0x2682012a4a4f1973119f1c9b90745d1bd91fa2bab387344f044cb3586864d18d)
```cpp
struct PayoutRedemption {
    address redeemer;          // indexed
    address collateralToken;   // indexed, USDC
    bytes32 parentCollectionId;// indexed
    bytes32 conditionId;
    uint256[] indexSets;       // 赎回的position组合
    uint256 payout;            // 赎回获得的USDC
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

#### ConditionResolution (topic0: 0xb44d84d3289691f71497564b85d4233648d9dbae8cbdbb4329f301c3a0185894)
```cpp
struct ConditionResolution {
    bytes32 conditionId;       // indexed
    address oracle;            // indexed, UmaCtfAdapter地址
    bytes32 questionId;        // indexed
    uint256 outcomeSlotCount;  // 固定为2
    uint256[] payoutNumerators;// [1,0]=YES赢, [0,1]=NO赢, [1,1]=平局
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

#### ConditionPreparation (topic0: 0xab3760c3bd2bb38b5bcf5b13adce5eb9d8f6fd2f241126ebab4a4c6a2792f80c)
```cpp
struct ConditionPreparation {
    bytes32 conditionId;       // indexed
    address oracle;            // indexed
    bytes32 questionId;        // indexed
    uint256 outcomeSlotCount;  // 固定为2
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

---

### 2. CTFExchange / NegRiskCTFExchange (共用结构)

#### OrderFilled (topic0: 0xd0a08e8c493f9c94f29311604c9de1b4e8c8d4c06bd0c789af57f2d65b5e35)
```cpp
struct OrderFilled {
    bytes32 orderHash;         // indexed
    address maker;             // indexed, 挂单方
    address taker;             // indexed, 吃单方
    uint256 makerAssetId;      // maker给出的tokenId (USDC=0)
    uint256 takerAssetId;      // taker给出的tokenId
    uint256 makerAmountFilled; // maker给出的数量
    uint256 takerAmountFilled; // taker给出的数量
    uint256 fee;               // 手续费 (USDC, 6 decimals)
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
    // 来源标记
    uint8 exchange_type;       // 0=CTFExchange, 1=NegRiskCTFExchange
};
```

#### OrdersMatched (topic0: 0x45d...多个maker被撮合)
```cpp
struct OrdersMatched {
    bytes32 takerOrderHash;    // indexed
    address takerOrderMaker;   // indexed, taker订单的maker
    uint256 makerAssetId;
    uint256 takerAssetId;
    uint256 makerAmountFilled;
    uint256 takerAmountFilled;
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
    uint8 exchange_type;
};
```

#### TokenRegistered (topic0: 0x...)
```cpp
struct TokenRegistered {
    uint256 token0;            // indexed, YES tokenId
    uint256 token1;            // indexed, NO tokenId
    bytes32 conditionId;       // indexed
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
    uint8 exchange_type;
};
```

---

### 3. NegRiskAdapter

#### MarketPrepared (topic0: 0x...)
```cpp
struct MarketPrepared {
    bytes32 marketId;          // indexed
    address oracle;            // NegRiskOperator地址
    uint256 feeBips;           // 手续费率 (万分比)
    bytes data;                // 市场元数据
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

#### QuestionPrepared (topic0: 0x...)
```cpp
struct QuestionPrepared {
    bytes32 marketId;          // indexed
    bytes32 questionId;        // indexed, = keccak256(marketId, questionIndex)
    uint256 questionIndex;
    bytes data;                // 问题元数据
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

#### PositionsConverted (topic0: 0x...)
```cpp
struct PositionsConverted {
    address stakeholder;       // indexed
    bytes32 marketId;          // indexed
    uint256 indexSet;          // 转换的NO position组合 (bitmap)
    uint256 amount;
    // tx metadata
    bytes32 tx_hash;
    uint64 block_number;
    uint32 log_index;
};
```

---

## 辅助数据结构

### ID计算 (CTHelpers)

```cpp
// conditionId = keccak256(oracle, questionId, outcomeSlotCount)
bytes32 getConditionId(address oracle, bytes32 questionId, uint256 outcomeSlotCount);

// collectionId = 椭圆曲线点加法 (parentCollectionId, conditionId, indexSet)
// 当 parentCollectionId = 0x0 时简化为:
//   indexSet=1(YES): collectionId = keccak256(conditionId, 1)
//   indexSet=2(NO):  collectionId = keccak256(conditionId, 2)
bytes32 getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet);

// positionId = keccak256(collateralToken, collectionId)
// 这就是 ERC1155 的 tokenId
uint256 getPositionId(address collateralToken, bytes32 collectionId);
```

### 索引表

```cpp
// positionId → conditionId 映射 (从TokenRegistered事件构建)
struct PositionMapping {
    uint256 positionId;        // YES或NO的tokenId
    uint256 complementId;      // 互补的tokenId
    bytes32 conditionId;
    bool isYes;                // true=YES, false=NO
};

// conditionId → 结算结果 (从ConditionResolution事件构建)
struct ConditionResult {
    bytes32 conditionId;
    bool resolved;
    uint256 winningOutcome;    // 0=YES, 1=NO, 2=平局
    uint256 payoutNumerator0;  // YES的payout
    uint256 payoutNumerator1;  // NO的payout
    uint256 payoutDenominator;
};
```

---

## 查询顺序

```
1. TokenRegistered (两个Exchange)
   → 构建 positionId ↔ conditionId 映射表

2. ConditionPreparation + ConditionResolution (ConditionalTokens)
   → 构建 conditionId 状态表

3. TransferSingle + TransferBatch (ConditionalTokens)
   → 按用户地址过滤，构建持仓变化流水

4. OrderFilled (两个Exchange)
   → 按用户地址过滤 (maker或taker)，计算成本和收入

5. PayoutRedemption (ConditionalTokens)
   → 按用户地址过滤，计算赎回收入
```

---

## 用户PnL计算

```cpp
struct UserPnL {
    address user;
    bytes32 conditionId;
    
    // 持仓
    int256 yesBalance;         // 当前YES数量 (负数表示做空)
    int256 noBalance;          // 当前NO数量
    
    // 成本追踪
    uint256 totalCostBasis;    // 买入总成本 (USDC)
    uint256 totalProceeds;     // 卖出总收入 (USDC)
    uint256 totalFees;         // 支付的手续费
    uint256 totalRedemption;   // 赎回获得的USDC
    
    // 计算: PnL = totalProceeds + totalRedemption - totalCostBasis - totalFees
};

┌─────────────────────────────────────────────────────────────────────┐
│                        Round 1: RPC → 原始表                         │
│                                                                     │
│  eth_getLogs ──────────────────────────────────────────────────────>│
│       │                                                             │
│       ▼                                                             │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ raw_log (暂存表，保持链上原始格式)                            │   │
│  │                                                             │   │
│  │ CREATE TABLE raw_log (                                      │   │
│  │     id INTEGER PRIMARY KEY,  -- block*10000+log_idx         │   │
│  │     block_number INTEGER,                                   │   │
│  │     log_index INTEGER,                                      │   │
│  │     event_type TEXT,         -- 'TokenRegistered' etc       │   │
│  │     contract TEXT,           -- 来源合约                     │   │
│  │     data TEXT                -- JSON: 原始解析字段           │   │
│  │ );                                                          │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  数据量: ~15M logs, 耗时 ~15min (本地 Erigon)                       │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                   Round 2: 原始表 → 最终表 (纯 SQL)                  │
│                                                                     │
│  Step 2.1: 构建映射表                                               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ -- token_map: 从 TokenRegistered 提取                        │   │
│  │ INSERT INTO token_map (token_id, condition_id, is_yes)       │   │
│  │ SELECT                                                       │   │
│  │     json_extract(data, '$.token0'),                          │   │
│  │     json_extract(data, '$.conditionId'),                     │   │
│  │     1                                                        │   │
│  │ FROM raw_log                                                 │   │
│  │ WHERE event_type = 'TokenRegistered'                         │   │
│  │   AND json_extract(data,'$.token0') < json_extract(data,'$.token1')│
│  │ UNION ALL                                                    │   │
│  │ SELECT                                                       │   │
│  │     json_extract(data, '$.token1'),                          │   │
│  │     json_extract(data, '$.conditionId'),                     │   │
│  │     0                                                        │   │
│  │ FROM raw_log                                                 │   │
│  │ WHERE event_type = 'TokenRegistered'                         │   │
│  │   AND json_extract(data,'$.token0') < json_extract(data,'$.token1')│
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ -- condition: 从 ConditionPreparation + Resolution           │   │
│  │ INSERT INTO condition (...)                                  │   │
│  │ SELECT ... FROM raw_log WHERE event_type='ConditionPreparation'│   │
│  │                                                             │   │
│  │ UPDATE condition SET payout_numerators=..., resolution_block=...│   │
│  │ FROM raw_log WHERE event_type='ConditionResolution'          │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  Step 2.2: 转换事件表                                               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ -- order_filled: 从 OrderFilled 计算 side/price/size         │   │
│  │ INSERT INTO order_filled (...)                               │   │
│  │ SELECT                                                       │   │
│  │     r.id,                                                    │   │
│  │     r.block_number,                                          │   │
│  │     r.log_index,                                             │   │
│  │     json_extract(r.data, '$.maker'),                         │   │
│  │     json_extract(r.data, '$.taker'),                         │   │
│  │     CASE WHEN maker_asset = 0                                │   │
│  │          THEN taker_asset ELSE maker_asset END AS market,    │   │
│  │     CASE WHEN maker_asset = 0                                │   │
│  │          THEN 'Buy' ELSE 'Sell' END AS side,                 │   │
│  │     CASE WHEN maker_asset = 0                                │   │
│  │          THEN maker_amt ELSE taker_amt END AS size,          │   │
│  │     ...                                                      │   │
│  │ FROM raw_log r                                               │   │
│  │ WHERE r.event_type = 'OrderFilled'                           │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ -- split/merge/redemption: 直接映射                          │   │
│  │ INSERT INTO split (...)                                      │   │
│  │ SELECT id, block_number, log_index,                          │   │
│  │        json_extract(data, '$.stakeholder'),                  │   │
│  │        json_extract(data, '$.conditionId'),                  │   │
│  │        json_extract(data, '$.amount')                        │   │
│  │ FROM raw_log WHERE event_type = 'PositionSplit'              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  Step 2.3: 建索引                                                   │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ CREATE INDEX idx_of_maker ON order_filled(maker);            │   │
│  │ CREATE INDEX idx_of_taker ON order_filled(taker);            │   │
│  │ CREATE INDEX idx_split_user ON split(stakeholder);           │   │
│  │ ...                                                          │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  Step 2.4 (可选): 清理暂存                                          │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ DROP TABLE raw_log;  -- 或保留用于调试                        │   │
│  │ VACUUM;                                                      │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  耗时: ~2min (纯数据库操作)                                         │
└─────────────────────────────────────────────────────────────────────┘

-- ============ 暂存表 (Round 1) ============
CREATE TABLE raw_log (
    id INTEGER PRIMARY KEY,       -- block_number * 10000 + log_index
    block_number INTEGER NOT NULL,
    log_index INTEGER NOT NULL,
    event_type TEXT NOT NULL,     -- 事件名
    contract TEXT NOT NULL,       -- 来源合约
    data TEXT NOT NULL            -- JSON: 所有字段
);

-- ============ 最终表 (Round 2) ============
CREATE TABLE token_map (
    token_id TEXT PRIMARY KEY,
    condition_id TEXT NOT NULL,
    is_yes INTEGER NOT NULL       -- 1=YES, 0=NO
);

CREATE TABLE condition (
    condition_id TEXT PRIMARY KEY,
    oracle TEXT,
    question_id TEXT,
    outcome_slot_count INTEGER,
    payout_numerators TEXT,       -- JSON array, NULL=未结算
    resolution_block INTEGER      -- NULL=未结算
);

CREATE TABLE order_filled (
    id INTEGER PRIMARY KEY,
    block_number INTEGER NOT NULL,
    log_index INTEGER NOT NULL,
    maker TEXT NOT NULL,
    taker TEXT NOT NULL,
    market TEXT NOT NULL,         -- tokenId
    side TEXT NOT NULL,           -- 'Buy'/'Sell'
    size INTEGER NOT NULL,        -- USDC (6 decimals)
    price_num INTEGER NOT NULL,
    price_den INTEGER NOT NULL,
    fee INTEGER NOT NULL
);

CREATE TABLE split (
    id INTEGER PRIMARY KEY,
    block_number INTEGER NOT NULL,
    log_index INTEGER NOT NULL,
    stakeholder TEXT NOT NULL,
    condition_id TEXT NOT NULL,
    amount INTEGER NOT NULL
);

CREATE TABLE merge (
    id INTEGER PRIMARY KEY,
    block_number INTEGER NOT NULL,
    log_index INTEGER NOT NULL,
    stakeholder TEXT NOT NULL,
    condition_id TEXT NOT NULL,
    amount INTEGER NOT NULL
);

CREATE TABLE redemption (
    id INTEGER PRIMARY KEY,
    block_number INTEGER NOT NULL,
    log_index INTEGER NOT NULL,
    redeemer TEXT NOT NULL,
    condition_id TEXT NOT NULL,
    index_sets TEXT NOT NULL,     -- JSON array
    payout INTEGER NOT NULL
);

-- ============ 同步状态表 ============
CREATE TABLE sync_state (
    key TEXT PRIMARY KEY,
    value INTEGER
);
-- key: 'last_block', 'round1_done', 'round2_done'

def round1_dump_raw(rpc_url, db):
    """RPC → raw_log 表"""
    last_block = db.execute("SELECT value FROM sync_state WHERE key='last_block'").fetchone()
    start = (last_block[0] + 1) if last_block else START_BLOCKS["ConditionalTokens"]
    head = get_head(rpc_url)
    
    CHUNK = 2000
    cur = start
    while cur <= head:
        end = min(cur + CHUNK - 1, head)
        
        # 批量查询所有合约的所有事件
        logs = rpc_batch(rpc_url, [
            ("eth_getLogs", [{"fromBlock": hex(cur), "toBlock": hex(end),
                            "address": CONTRACTS["ConditionalTokens"], "topics": [CT_TOPICS]}]),
            ("eth_getLogs", [{"fromBlock": hex(cur), "toBlock": hex(end),
                            "address": CONTRACTS["CTFExchange"], "topics": [EX_TOPICS]}]),
            # ...
        ])
        
        # 解析并写入 raw_log
        batch = []
        for log, contract_name in flatten_logs(logs):
            event_type, data = parse_log(log)
            row_id = int(log["blockNumber"], 16) * 10000 + int(log["logIndex"], 16)
            batch.append((row_id, int(log["blockNumber"], 16), 
                         int(log["logIndex"], 16), event_type, 
                         contract_name, json.dumps(data)))
        
        db.executemany("INSERT OR IGNORE INTO raw_log VALUES (?,?,?,?,?,?)", batch)
        db.execute("INSERT OR REPLACE INTO sync_state VALUES ('last_block', ?)", (end,))
        db.commit()
        
        cur = end + 1

def round2_transform(db):
    """raw_log → 最终表 (纯 SQL)"""
    
    # 2.1 token_map
    db.executescript("""
        INSERT INTO token_map (token_id, condition_id, is_yes)
        SELECT json_extract(data, '$.token0'), 
               json_extract(data, '$.conditionId'), 1
        FROM raw_log WHERE event_type = 'TokenRegistered'
          AND CAST(json_extract(data,'$.token0') AS INTEGER) 
            < CAST(json_extract(data,'$.token1') AS INTEGER);
        
        INSERT INTO token_map (token_id, condition_id, is_yes)
        SELECT json_extract(data, '$.token1'),
               json_extract(data, '$.conditionId'), 0
        FROM raw_log WHERE event_type = 'TokenRegistered'
          AND CAST(json_extract(data,'$.token0') AS INTEGER)
            < CAST(json_extract(data,'$.token1') AS INTEGER);
    """)
    
    # 2.2 condition
    db.executescript("""
        INSERT INTO condition (condition_id, oracle, question_id, outcome_slot_count)
        SELECT json_extract(data, '$.conditionId'),
               json_extract(data, '$.oracle'),
               json_extract(data, '$.questionId'),
               json_extract(data, '$.outcomeSlotCount')
        FROM raw_log WHERE event_type = 'ConditionPreparation';
        
        UPDATE condition SET
            payout_numerators = (SELECT json_extract(data, '$.payoutNumerators') 
                                FROM raw_log r WHERE r.event_type='ConditionResolution'
                                AND json_extract(r.data,'$.conditionId')=condition.condition_id),
            resolution_block = (SELECT block_number FROM raw_log r 
                               WHERE r.event_type='ConditionResolution'
                               AND json_extract(r.data,'$.conditionId')=condition.condition_id)
        WHERE EXISTS (SELECT 1 FROM raw_log r WHERE r.event_type='ConditionResolution'
                     AND json_extract(r.data,'$.conditionId')=condition.condition_id);
    """)
    
    # 2.3 order_filled (核心转换)
    db.execute("""
        INSERT INTO order_filled (id, block_number, log_index, maker, taker,
                                  market, side, size, price_num, price_den, fee)
        SELECT 
            id, block_number, log_index,
            json_extract(data, '$.maker'),
            json_extract(data, '$.taker'),
            CASE WHEN CAST(json_extract(data,'$.makerAssetId') AS INTEGER) = 0
                 THEN json_extract(data,'$.takerAssetId')
                 ELSE json_extract(data,'$.makerAssetId') END,
            CASE WHEN CAST(json_extract(data,'$.makerAssetId') AS INTEGER) = 0
                 THEN 'Buy' ELSE 'Sell' END,
            CASE WHEN CAST(json_extract(data,'$.makerAssetId') AS INTEGER) = 0
                 THEN CAST(json_extract(data,'$.makerAmountFilled') AS INTEGER)
                 ELSE CAST(json_extract(data,'$.takerAmountFilled') AS INTEGER) END,
            CAST(json_extract(data,'$.makerAmountFilled') AS INTEGER),
            CAST(json_extract(data,'$.takerAmountFilled') AS INTEGER),
            CAST(json_extract(data,'$.fee') AS INTEGER)
        FROM raw_log WHERE event_type = 'OrderFilled'
    """)
    
    # 2.4 split/merge/redemption (直接映射)
    db.execute("""
        INSERT INTO split (id, block_number, log_index, stakeholder, condition_id, amount)
        SELECT id, block_number, log_index,
               json_extract(data, '$.stakeholder'),
               json_extract(data, '$.conditionId'),
               CAST(json_extract(data, '$.amount') AS INTEGER)
        FROM raw_log WHERE event_type = 'PositionSplit'
    """)
    # merge, redemption 类似...
    
    # 2.5 建索引
    db.executescript("""
        CREATE INDEX idx_of_maker ON order_filled(maker);
        CREATE INDEX idx_of_taker ON order_filled(taker);
        CREATE INDEX idx_of_market ON order_filled(market);
        CREATE INDEX idx_split_user ON split(stakeholder);
        CREATE INDEX idx_merge_user ON merge(stakeholder);
        CREATE INDEX idx_redeem_user ON redemption(redeemer);
    """)
    
    db.execute("INSERT OR REPLACE INTO sync_state VALUES ('round2_done', 1)")
    db.commit()

```
